[{"categories":["eBPF","Linux Kernel","Golang"],"content":"目前使用 Go 开发 eBPF 程序可以使用的框架有 IO Visor-gobpf、Dropbox-goebpf和 Cilium-ebpf等，考虑到 Cilium 的社区活跃度和未来的发展，使用 Cilium 的 ebpf 是一个比较不错的选择。 ","date":"2022-03-15","objectID":"/cilium_ebpf/:0:0","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"一、环境搭建 0.基础环境 官方文档：https://github.com/cilium/ebpf Requirements A version of Go that is supported by upstream Linux \u003e= 4.4. CI is run against LTS releases. 建议使用较新的 Go 和内核版本，笔者使用的环境： Ubuntu 20.04（5.17.0-051700rc7-generic） go version go1.18 linux/amd64 1.安装依赖 apt install clang llvm 2.配置环境变量 export BPF_CLANG=clang 3.将Cilium eBPF克隆到本地： git clone https://github.com/cilium/ebpf.git 4.测试 进入kprobe目录： cd kprobe 删除之前生成的文件： rm *.o rm bpf_*.go 此时剩下的文件应为： . ├── kprobe.c └── main.go 在该目录下执行： go generate 此时该目录下的文件： $ tree . ├── bpf_bpfeb.go ├── bpf_bpfeb.o ├── bpf_bpfel.go ├── bpf_bpfel.o ├── kprobe.c └── main.go 可以看出，此操作分别生成了两对 .go 和 .o 文件。 继续执行： go build 生成了二进制文件kprobe 执行该二进制文件： $ sudo ./kprobe 2022/03/23 14:51:54 Waiting for events.. 2022/03/23 14:51:55 sys_execve called 6 times 2022/03/23 14:51:56 sys_execve called 25 times 2022/03/23 14:51:57 sys_execve called 35 times 2022/03/23 14:51:58 sys_execve called 37 times 打印的结果为执行sys_execve的次数，若正确输出则说明环境搭建成功。 ","date":"2022-03-15","objectID":"/cilium_ebpf/:0:1","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"二、创建自己的 Cilium eBPF 项目 建立并进入项目文件夹： mkdir YOUR_PATH \u0026\u0026 cd YOUR_PATH 将 Cilium eBPF examples 中的相关文件复制过来作为基础进行修改： cd CILIUM_EBPF_PATH/examples #替换为自己的Cilium eBPF路径 cp -r headers/ YOUR_PATH #头文件目录 cp kprobe/main.go YOUR_PATH #Go主程序 cp kprobe/kprobe.c YOUR_PATH #eBPF C程序 编辑 main.go： vim main.go 将第19行 //go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -c flags $BPF_CFLAGS bpf kprobe.c -- -I../headers 改为（修改了最后headers的相对路径） //go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -c flags $BPF_CFLAGS bpf kprobe.c -- -I./headers 关于 go generate 的原理： go generate命令是go 1.4版本里面新添加的一个命令，当运行go generate时，它将扫描与当前包相关的源代码文件，找出所有包含”//go:generate\"的特殊注释，提取并执行该特殊注释后面的命令，命令为可执行程序，形同shell下面执行。 在自己的项目目录下执行： go mod init YOUR_NAME 此时生成了go.mod文件，再继续执行： go mod tidy 将依赖添加到了go.mod 中 $ cat go.mod module YOUR_NAME go 1.18 require github.com/cilium/ebpf v0.8.1 require golang.org/x/sys v0.0.0-20210906170528-6f6e22806c34 // indirect 执行 go generate \u0026\u0026 go build 测试，若无报错并成功生成了 bpf_xxx.go、bpf_xxx.o文件和可执行文件则说明配置成功。 ","date":"2022-03-15","objectID":"/cilium_ebpf/:0:2","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"三、基于 kprobe 例程打造自己的 eBPF 程序 首先，我们先来分析一下 kprobe 例程中的代码。 main.go 中 main 函数前半部分： func main() { // Name of the kernel function to trace. fn := \"sys_execve\" // Allow the current process to lock memory for eBPF resources. if err := rlimit.RemoveMemlock(); err != nil { log.Fatal(err) } // Load pre-compiled programs and maps into the kernel. objs := bpfObjects{} if err := loadBpfObjects(\u0026objs, nil); err != nil { log.Fatalf(\"loading objects: %v\", err) } defer objs.Close() // Open a Kprobe at the entry point of the kernel function and attach the // pre-compiled program. Each time the kernel function enters, the program // will increment the execution counter by 1. The read loop below polls this // map value once per second. kp, err := link.Kprobe(fn, objs.KprobeExecve) if err != nil { log.Fatalf(\"opening kprobe: %s\", err) } defer kp.Close() fn中定义了kprobe附着的函数为sys_execve，并锁定当前进程 eBPF 资源的内存。 之后是调用loadBpfObjects将预先编译的 eBPF 程序和 maps 加载到内核，其定义在生成的.go文件中，最后是调用link.Kprobe进行真正的attach。 关于这个objs，其类型是bpfObjects，定义在生成的.go文件： // bpfSpecs contains maps and programs before they are loaded into the kernel. // // It can be passed ebpf.CollectionSpec.Assign. type bpfSpecs struct { bpfProgramSpecs bpfMapSpecs } bpfProgramSpecs、bpfMapSpecs的定义分别为： // bpfSpecs contains programs before they are loaded into the kernel. // // It can be passed ebpf.CollectionSpec.Assign. type bpfProgramSpecs struct { KprobeExecve *ebpf.ProgramSpec `ebpf:\"kprobe_execve\"` } // bpfMapSpecs contains maps before they are loaded into the kernel. // // It can be passed ebpf.CollectionSpec.Assign. type bpfMapSpecs struct { KprobeMap *ebpf.MapSpec `ebpf:\"kprobe_map\"` } kprobe_execve、kprobe_map分别对应 kprobe.c 文件中定义的： struct bpf_map_def SEC(\"maps\") kprobe_map = { ... }; SEC(\"kprobe/sys_execve\") int kprobe_execve() { ... } 所以，Go 中的这两个名字 KprobeExecve、KprobeMap 就是根据 C 程序中的这两个名字生成过来的，规则是：首字母大写，去除下划线_并大写后一个字母。 监听open系统调用，获取filename 现在，我们准备利用刚刚创建的 Cilium eBPF 项目，编写一个可以监听 open 系统调用，获取 filename 的程序。首先先看一下open系统调用： SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode) |--do_sys_open(AT_FDCWD, filename, flags, mode); |--do_sys_openat2(dfd, filename, \u0026how); static long do_sys_openat2(int dfd, const char __user *filename, struct open_how *how) { ... 我们的目标是获取do_sys_openat2的第二个参数filename。打开kprobe.c开始改造： 将宏SEC的名字和函数名改为： SEC(\"kprobe/do_sys_openat2\") int kprobe_openat2(struct pt_regs *ctx) { ... 我们想知道当前是哪个进程进行了open系统调用，所以可以通过BPF辅助函数bpf_get_current_pid_tgid获得当前pid_tgid： u32 pid = bpf_get_current_pid_tgid() \u003e\u003e 32; 关于BPF辅助函数，可以参考文档：https://www.man7.org/linux/man-pages/man7/bpf-helpers.7.html 那么怎么获取到 filename 呢？ filename 在kprobe_openat2的第二个参数，可以通过PT_REGS_PARM2宏获取，其定义在bpf_tracing.h： #define PT_REGS_PARM1(x) ((x)-\u003erdi) #define PT_REGS_PARM2(x) ((x)-\u003ersi) #define PT_REGS_PARM3(x) ((x)-\u003erdx) #define PT_REGS_PARM4(x) ((x)-\u003ercx) #define PT_REGS_PARM5(x) ((x)-\u003er8) #define PT_REGS_RET(x) ((x)-\u003ersp) （所以需要在 kprobe.c 中 #include \"bpf_tracing.h\"） __user代表该数据在用户空间，所以需要bpf_probe_read_user_str读取: char filename[20]; const char *fp = (char *)PT_REGS_PARM2(ctx); long err = bpf_probe_read_user_str(filename, sizeof(filename), fp); 之后可以通过bpf_printk将这些数据输出到/sys/kernel/debug/tracing/trace中： bpf_printk(\"pid:%d,filename:%s,err:%ld\",pid,filename,err); kprobe.c 改造结束了，但是使用PT_REGS_PARM2需要指定target，在main.go中，继续修改第19行为： //go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -cflags $BPF_CFLAGS --target=amd64 bpf kprobe.c -- -I./headers 我所使用的机器平台为amd64，所以我加上了--target=amd64 删除之前生成的文件，否则可能会在之后报错： rm *.o rm bpf_*.go 执行 go generate 调用bpf2go生成，此次由于指定了target为amd64，所以生成的文件为： bpf_bpfel_x86.go bpf_bpfel_x86.o 打开 bpf_bpfel_x86.go 由于我们修改了 kprobe.c 中的函数名，所以此处也对应的发生了改变： type bpfProgramSpecs struct { KprobeOpenat2 *ebpf.ProgramSpec `ebpf:\"kprobe_openat2\"` } 我们需要将 main.go 一并更改（第44行）： kp, err := link.Kprobe(fn, objs.KprobeOpenat2) 然后更改fn为我们要 attach 的函数 do_sys_openat2（第26行）： fn := \"do_sys_openat2\" 最后，生成二进制文件并运行： $ go build \u0026\u0026 sudo ./YOUR_NAME 2022/03/23 17:01:03 Waiting for events.. 2022/03/23 17:01:04 do_sys_openat2 calle","date":"2022-03-15","objectID":"/cilium_ebpf/:0:3","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"参考文献 https://zhuanlan.zhihu.com/p/466893888 https://blog.csdn.net/qq_31362439/article/details/122727406 https://www.jianshu.com/p/a866147021da https://blog.csdn.net/jasonactions/article/details/116125922 https://szp2016.github.io/uncategorized/ebpf%E5%85%A5%E9%97%A8/ ","date":"2022-03-15","objectID":"/cilium_ebpf/:0:4","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"More about me 欢迎关注 「barryX的技术笔记」 微信公众号 ","date":"2022-03-15","objectID":"/cilium_ebpf/:0:5","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["杂"],"content":"这篇文章是把博客从阿里云迁到腾讯云上之后的第一篇博客。 之前是在阿里云上使用WordPress搭建的，但是感觉比较臃肿，而且之前也就写过几篇博客，干脆就重新搭建一个。因为我现在一般都用Markdown格式写东西，所以就打算找一个利用Markdown生成静态网站的工具。 我目前有两台电脑，一台Windows笔记本、一台MacMini。 搭建了以下环境： Typora（编辑Markdown文档） 坚果云（作为Typora的工作目录，每次保存可以同步，也便于我在两台电脑之间切换） Gitee图床 (存放静态图片） PicGo （配置Typora，将图片自动上传到Gitee图床） 服务器端： Hugo （生成静态页面） Docker （容器化） Nginx （作为静态页面的web服务器） 并且我在Gitee上单独开了一个仓库，存放Hugo生成的站点，并且开通了Gitee Pages。 我的想法是这样的： 使用Typora编写内容。 将编写好的内容，放到Hugo中，并生成静态页面。（因为Nginx的网页目录就是public，所以此时已经可以通过域名访问到） 将站点通过git push到Gitee中，并在Gitee Pages中部署。 以上在环境方面的准备，接下来是内容方面的准备。 目前研一在读，研究方向大体为Linux Kernel、eBPF、内核网络、Golang这些，所以博客的内容主要以学习这些的笔记为主。 初学者难免会犯一些错误，如果有问题的话，欢迎大家向我指出！感谢！ 可以发邮件：i@barryx.cn 或者在Gitee中提交issue：https://gitee.com/barryx/barryx_blog/ ","date":"2022-03-15","objectID":"/hello_world/:0:0","tags":null,"title":"Hello World!","uri":"/hello_world/"}]