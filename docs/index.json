[{"categories":["eBPF"],"content":"（原文链接：https://www.containiq.com/post/libbpf） 本文讨论了 libbpf 及其在开发 BPF 工具和应用程序时相对于 BCC 的优势。包括代码示例和入门指南。 BPF 应用程序让工程师可以直接了解操作系统的底层。这些应用程序可以通过内核子系统中的挂钩（hooks）来监控性能和访问资源。 不过，在内核应用程序上工作是一种微妙的平衡。你需要确保在一系列系统上的兼容性，并避免任何过时或弃用的东西。BCC 可以简化该过程，但 libbpf 的优势使其在许多情况下成为更好的解决方案。 在本文中，你将了解 libbpf 与 BCC 的不同之处、如何使用它，以及在你决定进行切换时它提供了什么。我们来看看： BCC及其问题 什么是 libbpf？ Libbpf 和 BPF CO-RE Libbpf 相对于 BCC 的优势 libbpf 是如何工作的？ 你为什么要使用它？ 开始使用 libbpf ","date":"2022-07-02","objectID":"/libbpf_a_beginners_guide/:0:0","tags":null,"title":"【译】 Libbpf：初学者指南","uri":"/libbpf_a_beginners_guide/"},{"categories":["eBPF"],"content":"什么是 BPF？ Berkeley Packet Filter 或BPF最初是一个虚拟机，它允许程序员更安全、更轻松地访问低级内核功能。根据Netflix 工程师 Brendan Gregg的说法，它后来演变成“通用内核执行引擎” 。它确保程序不会崩溃或无限期地运行，这是程序员与操作系统交互方式的重大变化。 BPF 的效率意味着它被用来驱动一些最大的站点。Facebook在每台服务器上运行着 40 多个 BPF 程序，有时多达一百个。 BCC 是使用 BPF 的老牌玩家，而 libbpf 是新来的。 BCC及其问题 BCC 或BPF Compiler Collection使用扩展的 BPF 来更轻松地创建低级程序。C 是一种常见的语言选择，但 Lua、Python、C++ 和 Rust 都是可行的替代方案。 它提供了大量示例和工具以及有用的错误消息，有助于确保你的 BPF 程序是正确的。 但是，BCC 也有缺点。它嵌入编译器组件，例如 Clang，并在运行时编译程序。这需要额外的 CPU 和内存，并且可能会暴露仅在编译程序时出现的问题。 BCC 需要内核头包，这意味着它们必须安装在目标主机上。如果你使用多台机器，会很困难。这也意味着需要在源代码中使用未导出内核内容的类型定义，这会很混乱。 ","date":"2022-07-02","objectID":"/libbpf_a_beginners_guide/:0:1","tags":null,"title":"【译】 Libbpf：初学者指南","uri":"/libbpf_a_beginners_guide/"},{"categories":["eBPF"],"content":"什么是Libbpf？ Libbpf 是一组用于构建 BPF 应用程序的替代工具。对于网络、安全和分析应用程序，它提供了优于 BCC 的几个潜在优势。 Libbpf 和 BPF CO-RE Libbpf 通常与 BPF CO-RE 一起使用（编译一次，到处运行）。BPF CO-RE 旨在解决 BPF 的可移植性问题，允许你创建在不同内核版本上运行的二进制文件。 它包括BPF 类型格式 (BTF)信息。这意味着你需要使用在编译时设置了CONFIG_DEBUG_INFO_BTF=y的内核构建。如果你使用的是标准的消费者 Linux 版本，则需要进行自定义编译以启用此功能；否则，你会遇到错误。 Libbpf 相对于 BCC 的优势 Libbpf 通过消除各种令人头疼的问题，使开发人员可以专注于手头的任务。 它生成简单的二进制文件，编译一次就可以在任何地方运行。它消除了许多依赖关系并尽可能接近一对一地执行你的代码。 为了运行用BCC编译的程序，需要安装的LLVM、内核和头文件的依赖性可能会超过100MB。并且消除包括LLVM和Clang库在内的开销会导致更小的二进制文件。 例如，一个包含它们的工具使用 BCC 编译为 645 KB。使用 libbpf 工具重新编译的工具生成了一个只有 151 KB 的可移植二进制文件。这大幅度减少了程序的体积。 Libbpf 还创建使用更少内存的二进制文件，例如，与使用 Python 的 BCC 占用 80 MB 相比，libbpf 内存占用为 9 MB 。 ","date":"2022-07-02","objectID":"/libbpf_a_beginners_guide/:0:2","tags":null,"title":"【译】 Libbpf：初学者指南","uri":"/libbpf_a_beginners_guide/"},{"categories":["eBPF"],"content":"Libbpf 是如何工作的？ Libbpf作为一个BPF程序加载器。它加载、检查和重新定位BPF程序，整理出地图和钩子。这使开发者可以自由地实现他们的程序而不必做所有的内务（housekeeping）工作。 偏移量和类型被自动匹配和更新，这意味着一个程序可以在目标主机上运行，而不需要昂贵的附加软件，如Clang。你实际上是在编写一个普通的C语言用户模式程序，做你期望的事情，没有任何意外。 libbpf 实现此目的的一种方法是使用 vmheader 文件，该文件包含多种内核类型，因此你不依赖于系统范围的内核头文件。这意味着要从 BCC 切换到 libbpf，你需要包含 vmlinux.h。 一个 BPF 应用程序会经历几个阶段： ‍ 打开阶段 —— BPF 程序在发现映射、变量和全局变量时暂停。 ‍ 加载阶段 —— 创建映射。BPF 程序被加载到内核中并被验证。 ‍ 附加阶段 —— BPF 程序附加到钩子上，准备工作。 ‍ 拆除（Tear Down）阶段 —— 当 BPF 程序从内核中分离和卸载时，资源被释放。 如果你查看下面的 minimum.c，你将看到与每个阶段相对应的函数（销毁用于拆除阶段）。 如果你不需要进行运行时调整，可以组合打开和加载阶段。使用这个功能： \u003cname\u003e_open_and_load() 如果需要，你还可以修改附加阶段以选择性地附加资源。 ","date":"2022-07-02","objectID":"/libbpf_a_beginners_guide/:0:3","tags":null,"title":"【译】 Libbpf：初学者指南","uri":"/libbpf_a_beginners_guide/"},{"categories":["eBPF"],"content":"为什么要使用Libbpf？ Libpf 提供了几个好处。它不需要依赖关系，使其在多台机器上使用起来更快、更容易。使用你的程序的人越多，这种优势就越大。 它在资源使用、输出更小的二进制文件和使用更少的内存方面更好，这使其非常适合系统关键任务。它对性能的有限影响也使其成为监控、安全和分析的理想选择。 ","date":"2022-07-02","objectID":"/libbpf_a_beginners_guide/:0:4","tags":null,"title":"【译】 Libbpf：初学者指南","uri":"/libbpf_a_beginners_guide/"},{"categories":["eBPF"],"content":"开始使用 Libbpf 要开始使用，请尝试 GitHub 上的libbpf-bootstrap演示应用程序。下载 repo 后，你可以使用 Make 和 Sudo 构建各种示例。下面是为 Minimal 演示构建和测试一些输出的示例： cd examples/c make minimal sudo ./minimal sudo cat/sys/kernel/debug/tracing/trace_pipe 此代码和下面的代码来自 libbpf-bootstrap 存储库并使用BSD 3-Clause 许可证。 这是一个 libbpf hello world的示例： minimal.bpf.c: // SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause /* Copyright (c) 2020 Facebook */ #include \u003clinux/bpf.h\u003e#include \u003cbpf/bpf_helpers.h\u003e char LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\"; int my_pid = 0; SEC(\"tp/syscalls/sys_enter_write\" int handle_tp(void *ctx) { int pid = bpf_get_current_pid_tgid() \u003e\u003e 32; if (pid != my_pid) return 0; bpf_printk(\"BPF triggered from PID %d.\\n\", pid); return 0; } 及其配套文件minimum.c： // SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) /* Copyright (c) 2020 Facebook */ #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003csys/resource.h\u003e#include \u003cbpf/libbpf.h\u003e#include \"minimal.skel.h\" static int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args) { return vfprintf(stderr, format, args); } static void bump_memlock_rlimit(void) { struct rlimit rlim_new = { .rlim_cur = RLIM_INFINITY, .rlim_max = RLIM_INFINITY, }; if (setrlimit(RLIMIT_MEMLOCK, \u0026rlim_new)) { fprintf(stderr, \"Failed to increase RLIMIT_MEMLOCK limit!\\n\"); exit(1); } } int main(int argc, char **argv) { struct minimal_bpf *skel; int err; /* Set up libbpf errors and debug info callback */ libbpf_set_print(libbpf_print_fn); /* Bump RLIMIT_MEMLOCK to allow BPF sub-system to do anything */ bump_memlock_rlimit(); /* Open BPF application */ skel = minimal_bpf_open(); if (!skel) { fprintf(stderr, \"Failed to open BPF skeleton\\n\"); return 1; } /* ensure BPF program only handles write() syscalls from our process */ skel-\u003ebss-\u003emy_pid = getpid(); /* Load \u0026 verify BPF programs */ err = minimal_bpf_load(skel); if (err) { fprintf(stderr, \"Failed to load and verify BPF skeleton\\n\"); goto cleanup; } /* Attach tracepoint handler */ err = minimal_bpf_attach(skel); if (err) { fprintf(stderr, \"Failed to attach BPF skeleton\\n\"); goto cleanup; } printf(\"Successfully started! Please run `sudo cat /sys/kernel/debug/tracing/trace_pipe`\" \"to see output of the BPF programs.\\n\"); for (;;) { /* trigger our BPF program */ fprintf(stderr, \".\"); sleep(1); } cleanup: minimal_bpf_destroy(skel); return -err; } ","date":"2022-07-02","objectID":"/libbpf_a_beginners_guide/:0:5","tags":null,"title":"【译】 Libbpf：初学者指南","uri":"/libbpf_a_beginners_guide/"},{"categories":["eBPF"],"content":"更多提示 除了 Minimal，libbpf-bootstrap GitHub示例文件夹中还有其他几个有用的示例： Bootstrap – 它跟踪流程并为你提供有关它们的统计信息，向你展示如何执行一些基本任务。如果你想编写监控或性能跟踪应用程序，请先看这里。 Tracecon – Rust 爱好者可以查看 tracecon，这是一个 Rust \u0026 Co. 应用程序，可让你跟踪机器上的所有 TCPv4 连接。 Uprobe – 这向你展示了如何使用用户空间探针，让你跟踪参数和输出。 Fentry – 这些是基于 fentry 和 fexit 的跟踪程序。它们的性能优于 kprobes，但需要至少 5.5 的内核版本。 Kprobe - 此功能是另一个与内核空间入口和出口探测器一起使用的日志记录示例。 XDP – 这是一个记录数据包大小的 Rust 示例。 如果你在使用 libbpf 时遇到任何问题，请查看其日志输出。它不使用 BCC 删除内存限制的方法来确保程序可以成功加载到内核中。 为确保你有足够的内存，你可以在程序开始时调用 setrlimit。你可以在上面的 minimum.c 中看到一个示例。 正如这些示例所示，切换到 libbpf 并不太痛苦，如果你遇到上述任何问题，那么切换是非常值得的。 ","date":"2022-07-02","objectID":"/libbpf_a_beginners_guide/:0:6","tags":null,"title":"【译】 Libbpf：初学者指南","uri":"/libbpf_a_beginners_guide/"},{"categories":["eBPF"],"content":"结论 BPF 为你提供了可观察性的超能力，但它的可移植性和资源使用存在问题。Libbpf 可以帮助你缓解这些问题，如果你正在创建底层 Linux 软件，就会给你带来很大的帮助。 Libbpf 生成的文件较小，比 BCC 生成的文件使用的内存少。它还删除了依赖关系，使你的代码更简单，不再需要内核导入。这意味着你可以写出更干净的代码，在文件的开头有更少的包含，而且你的输出更容易让客户安装。 在两者的直接比较中，libbpf是一个明显的赢家。从 BCC 转换是很容易做到的。Libbpf 更低的资源使用量和更大的可移植性简化了你的工作，使你的最终产品对你的客户更有吸引力，所以你从这个改变中可以获得很多好处。 ","date":"2022-07-02","objectID":"/libbpf_a_beginners_guide/:0:7","tags":null,"title":"【译】 Libbpf：初学者指南","uri":"/libbpf_a_beginners_guide/"},{"categories":["eBPF"],"content":"More about me 欢迎关注 「barryX的技术笔记」 微信公众号 ","date":"2022-07-02","objectID":"/libbpf_a_beginners_guide/:0:8","tags":null,"title":"【译】 Libbpf：初学者指南","uri":"/libbpf_a_beginners_guide/"},{"categories":["Linux Kernel","杂"],"content":"平时经常使用elixir.bootlin.com查看内核源码，很方便。但是苦于该站点服务器在国外，国内用起来很卡很慢，所以想着自己在本地搭一个。 ","date":"2022-06-25","objectID":"/build_bootlin_elixir/:0:0","tags":null,"title":"本地搭建 Bootlin elixir 查阅内核代码","uri":"/build_bootlin_elixir/"},{"categories":["Linux Kernel","杂"],"content":"使用环境 Host：Ubuntu 20.04 （Kernel 5.15） Docker：ubuntu:latest ","date":"2022-06-25","objectID":"/build_bootlin_elixir/:0:1","tags":null,"title":"本地搭建 Bootlin elixir 查阅内核代码","uri":"/build_bootlin_elixir/"},{"categories":["Linux Kernel","杂"],"content":"准备工作 安装依赖 apt-get -y install python3 python3-pip python3-jinja2 python3-bsddb3 python3-pytest perl git libjansson4 libyaml-0-2 wget pip3 install falcon 下载两个特殊依赖并安装 wget https://bootlin.com/pub/elixir/universal-ctags_0+git20200526-0ubuntu1_amd64.deb wget https://bootlin.com/pub/elixir/Pygments-2.6.1.elixir-py3-none-any.whl dpkg -i universal-ctags_0+git20200526-0ubuntu1_amd64.deb pip3 install Pygments-2.6.1.elixir-py3-none-any.whl 配置环境变量 修改/etc/profile，在末尾增加（具体路径可改为其它） export LXR_REPO_DIR=/srv/elixir-data/linux/repo export LXR_DATA_DIR=/srv/elixir-data/linux/data 使环境变量生效 source /etc/profile 下载配置kernel源码 下载kernel源码（建议使用清华大学开源镜像站：https://mirrors.tuna.tsinghua.edu.cn/kernel/） （以5.15内核为例，可以根据需要自行调整） wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.15.33.tar.gz 建立相应目录 mkdir -p $LXR_REPO_DIR mkdir -p $LXR_DATA_DIR 解压至$LXR_REPO_DIR tar -zvxf linux-5.15.33.tar.gz --strip-components 1 -C $LXR_REPO_DIR ","date":"2022-06-25","objectID":"/build_bootlin_elixir/:0:2","tags":null,"title":"本地搭建 Bootlin elixir 查阅内核代码","uri":"/build_bootlin_elixir/"},{"categories":["Linux Kernel","杂"],"content":"配置apache服务器 安装依赖 apt install -y apache2 libapache2-mod-wsgi-py3 修改/etc/apache2/sites-available/000-default.conf （默认监听80端口，可以按照自己需要调整） \u003cDirectory /usr/local/elixir/http/\u003e Options +ExecCGI AllowOverride None Require all granted SetEnv PYTHONIOENCODING utf-8 SetEnv LXR_PROJ_DIR /srv/elixir-data \u003c/Directory\u003e \u003cDirectory /usr/local/elixir/api/\u003e SetHandler wsgi-script Require all granted SetEnv PYTHONIOENCODING utf-8 SetEnv LXR_PROJ_DIR /srv/elixir-data \u003c/Directory\u003e AddHandler cgi-script .py \u003cVirtualHost *:80\u003e ServerName MY_LOCAL_IP DocumentRoot /usr/local/elixir/http WSGIScriptAlias /api /usr/local/elixir/api/api.py AllowEncodedSlashes On RewriteEngine on RewriteRule \"^/$\" \"/linux/latest/source\" [R] RewriteRule \"^/(?!api|acp).*/(source|ident|search)\" \"/web.py\" [PT] RewriteRule \"^/acp\" \"/autocomplete.py\" [PT] \u003c/VirtualHost\u003e 配置apache.conf echo -e \"\\nHttpProtocolOptions Unsafe\" \u003e\u003e /etc/apache2/apache.conf 开启依赖模块 a2enmod cgi rewrite 启动apache /usr/sbin/apache2ctl -D FOREGROUND ","date":"2022-06-25","objectID":"/build_bootlin_elixir/:0:3","tags":null,"title":"本地搭建 Bootlin elixir 查阅内核代码","uri":"/build_bootlin_elixir/"},{"categories":["Linux Kernel","杂"],"content":"安装配置bootlin/exilir 进入$LXR_REPO_DIR目录，更改REPO目录以及www-data的用户目录所有者为www-data cd $LXR_REPO_DIR cd .. chown -R www-data ./repo cd /var chown -R www-data ./www 切换账号到www-data操作（避免一些权限问题引起的错误） 修改/etc/passwd，使其可以登录。找到www-data一行，将其改为 www-data:x:33:33:www-data:/var/www:/bin/bash 修改www-data用户密码（自己设置一个） passwd www-data 切换至www-data（可能提示输入密码，输入上面设置的就行） su www-data 回到$LXR_REPO_DIR，进行git初始化（带有v5.15版本号的可以根据自己需要调整） cd $LXR_REPO_DIR git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" git init git add . git commit -m 'v5.15' git tag v5.15 切换回管理员用户，如su ubuntu，将bootlin/elixir项目clone下载 git clone https://github.com/bootlin/elixir.git /usr/local/elixir/ （最好不要修改/usr/local/elixir/） 生成索引 git config --global --add safe.directory $LXR_REPO_DIR cd /usr/local/elixir/ python3 update.py （大约需等待一小时左右） 大功告成，在浏览器输入对应地址即可查看~ 官方给出了dockerfile：https://github.com/bootlin/elixir/tree/master/docker，但笔者使用这个安装后打开浏览器是空白页面，推测是权限问题，所以选择了手动配置。 ","date":"2022-06-25","objectID":"/build_bootlin_elixir/:0:4","tags":null,"title":"本地搭建 Bootlin elixir 查阅内核代码","uri":"/build_bootlin_elixir/"},{"categories":["Linux Kernel","杂"],"content":"Ref bootlin/elixir：https://github.com/bootlin/elixir ","date":"2022-06-25","objectID":"/build_bootlin_elixir/:0:5","tags":null,"title":"本地搭建 Bootlin elixir 查阅内核代码","uri":"/build_bootlin_elixir/"},{"categories":["Linux Kernel","杂"],"content":"More about me 欢迎关注 「barryX的技术笔记」 微信公众号 ","date":"2022-06-25","objectID":"/build_bootlin_elixir/:0:6","tags":null,"title":"本地搭建 Bootlin elixir 查阅内核代码","uri":"/build_bootlin_elixir/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"目前使用 Go 开发 eBPF 程序可以使用的框架有 IO Visor-gobpf、Dropbox-goebpf和 Cilium-ebpf等，考虑到 Cilium 的社区活跃度和未来的发展，使用 Cilium 的 ebpf 是一个比较不错的选择。 ","date":"2022-03-15","objectID":"/cilium_ebpf/:0:0","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"一、环境搭建 0.基础环境 官方文档：https://github.com/cilium/ebpf Requirements A version of Go that is supported by upstream Linux \u003e= 4.4. CI is run against LTS releases. 建议使用较新的 Go 和内核版本，笔者使用的环境： Ubuntu 20.04（5.17.0-051700rc7-generic） go version go1.18 linux/amd64 1.安装依赖 apt install clang llvm 2.配置环境变量 export BPF_CLANG=clang 3.将Cilium eBPF克隆到本地： git clone https://github.com/cilium/ebpf.git 4.测试 进入kprobe目录： cd kprobe 删除之前生成的文件： rm *.o rm bpf_*.go 此时剩下的文件应为： . ├── kprobe.c └── main.go 在该目录下执行： go generate 此时该目录下的文件： $ tree . ├── bpf_bpfeb.go ├── bpf_bpfeb.o ├── bpf_bpfel.go ├── bpf_bpfel.o ├── kprobe.c └── main.go 可以看出，此操作分别生成了两对 .go 和 .o 文件。 继续执行： go build 生成了二进制文件kprobe 执行该二进制文件： $ sudo ./kprobe 2022/03/23 14:51:54 Waiting for events.. 2022/03/23 14:51:55 sys_execve called 6 times 2022/03/23 14:51:56 sys_execve called 25 times 2022/03/23 14:51:57 sys_execve called 35 times 2022/03/23 14:51:58 sys_execve called 37 times 打印的结果为执行sys_execve的次数，若正确输出则说明环境搭建成功。 ","date":"2022-03-15","objectID":"/cilium_ebpf/:0:1","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"二、创建自己的 Cilium eBPF 项目 建立并进入项目文件夹： mkdir YOUR_PATH \u0026\u0026 cd YOUR_PATH 将 Cilium eBPF examples 中的相关文件复制过来作为基础进行修改： cd CILIUM_EBPF_PATH/examples #替换为自己的Cilium eBPF路径 cp -r headers/ YOUR_PATH #头文件目录 cp kprobe/main.go YOUR_PATH #Go主程序 cp kprobe/kprobe.c YOUR_PATH #eBPF C程序 编辑 main.go： vim main.go 将第19行 //go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -c flags $BPF_CFLAGS bpf kprobe.c -- -I../headers 改为（修改了最后headers的相对路径） //go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -c flags $BPF_CFLAGS bpf kprobe.c -- -I./headers 关于 go generate 的原理： go generate命令是go 1.4版本里面新添加的一个命令，当运行go generate时，它将扫描与当前包相关的源代码文件，找出所有包含\"//go:generate\"的特殊注释，提取并执行该特殊注释后面的命令，命令为可执行程序，形同shell下面执行。 在自己的项目目录下执行： go mod init YOUR_NAME 此时生成了go.mod文件，再继续执行： go mod tidy 将依赖添加到了go.mod 中 $ cat go.mod module YOUR_NAME go 1.18 require github.com/cilium/ebpf v0.8.1 require golang.org/x/sys v0.0.0-20210906170528-6f6e22806c34 // indirect 执行 go generate \u0026\u0026 go build 测试，若无报错并成功生成了 bpf_xxx.go、bpf_xxx.o文件和可执行文件则说明配置成功。 ","date":"2022-03-15","objectID":"/cilium_ebpf/:0:2","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"三、基于 kprobe 例程打造自己的 eBPF 程序 首先，我们先来分析一下 kprobe 例程中的代码。 main.go 中 main 函数前半部分： func main() { // Name of the kernel function to trace. fn := \"sys_execve\" // Allow the current process to lock memory for eBPF resources. if err := rlimit.RemoveMemlock(); err != nil { log.Fatal(err) } // Load pre-compiled programs and maps into the kernel. objs := bpfObjects{} if err := loadBpfObjects(\u0026objs, nil); err != nil { log.Fatalf(\"loading objects: %v\", err) } defer objs.Close() // Open a Kprobe at the entry point of the kernel function and attach the // pre-compiled program. Each time the kernel function enters, the program // will increment the execution counter by 1. The read loop below polls this // map value once per second. kp, err := link.Kprobe(fn, objs.KprobeExecve) if err != nil { log.Fatalf(\"opening kprobe: %s\", err) } defer kp.Close() fn中定义了kprobe附着的函数为sys_execve，并锁定当前进程 eBPF 资源的内存。 之后是调用loadBpfObjects将预先编译的 eBPF 程序和 maps 加载到内核，其定义在生成的.go文件中，最后是调用link.Kprobe进行真正的attach。 关于这个objs，其类型是bpfObjects，定义在生成的.go文件： // bpfSpecs contains maps and programs before they are loaded into the kernel. // // It can be passed ebpf.CollectionSpec.Assign. type bpfSpecs struct { bpfProgramSpecs bpfMapSpecs } bpfProgramSpecs、bpfMapSpecs的定义分别为： // bpfSpecs contains programs before they are loaded into the kernel. // // It can be passed ebpf.CollectionSpec.Assign. type bpfProgramSpecs struct { KprobeExecve *ebpf.ProgramSpec `ebpf:\"kprobe_execve\"` } // bpfMapSpecs contains maps before they are loaded into the kernel. // // It can be passed ebpf.CollectionSpec.Assign. type bpfMapSpecs struct { KprobeMap *ebpf.MapSpec `ebpf:\"kprobe_map\"` } kprobe_execve、kprobe_map分别对应 kprobe.c 文件中定义的： struct bpf_map_def SEC(\"maps\") kprobe_map = { ... }; SEC(\"kprobe/sys_execve\") int kprobe_execve() { ... } 所以，Go 中的这两个名字 KprobeExecve、KprobeMap 就是根据 C 程序中的这两个名字生成过来的，规则是：首字母大写，去除下划线_并大写后一个字母。 监听open系统调用，获取filename 现在，我们准备利用刚刚创建的 Cilium eBPF 项目，编写一个可以监听 open 系统调用，获取 filename 的程序。首先先看一下open系统调用： SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode) |--do_sys_open(AT_FDCWD, filename, flags, mode); |--do_sys_openat2(dfd, filename, \u0026how); static long do_sys_openat2(int dfd, const char __user *filename, struct open_how *how) { ... 我们的目标是获取do_sys_openat2的第二个参数filename。打开kprobe.c开始改造： 将宏SEC的名字和函数名改为： SEC(\"kprobe/do_sys_openat2\") int kprobe_openat2(struct pt_regs *ctx) { ... 我们想知道当前是哪个进程进行了open系统调用，所以可以通过BPF辅助函数bpf_get_current_pid_tgid获得当前pid_tgid： u32 pid = bpf_get_current_pid_tgid() \u003e\u003e 32; 关于BPF辅助函数，可以参考文档：https://www.man7.org/linux/man-pages/man7/bpf-helpers.7.html 那么怎么获取到 filename 呢？ filename 在kprobe_openat2的第二个参数，可以通过PT_REGS_PARM2宏获取，其定义在bpf_tracing.h： #define PT_REGS_PARM1(x) ((x)-\u003erdi) #define PT_REGS_PARM2(x) ((x)-\u003ersi) #define PT_REGS_PARM3(x) ((x)-\u003erdx) #define PT_REGS_PARM4(x) ((x)-\u003ercx) #define PT_REGS_PARM5(x) ((x)-\u003er8) #define PT_REGS_RET(x) ((x)-\u003ersp) （所以需要在 kprobe.c 中 #include \"bpf_tracing.h\"） __user代表该数据在用户空间，所以需要bpf_probe_read_user_str读取: char filename[20]; const char *fp = (char *)PT_REGS_PARM2(ctx); long err = bpf_probe_read_user_str(filename, sizeof(filename), fp); 之后可以通过bpf_printk将这些数据输出到/sys/kernel/debug/tracing/trace中： bpf_printk(\"pid:%d,filename:%s,err:%ld\",pid,filename,err); kprobe.c 改造结束了，但是使用PT_REGS_PARM2需要指定target，在main.go中，继续修改第19行为： //go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -cflags $BPF_CFLAGS --target=amd64 bpf kprobe.c -- -I./headers 我所使用的机器平台为amd64，所以我加上了--target=amd64 删除之前生成的文件，否则可能会在之后报错： rm *.o rm bpf_*.go 执行 go generate 调用bpf2go生成，此次由于指定了target为amd64，所以生成的文件为： bpf_bpfel_x86.go bpf_bpfel_x86.o 打开 bpf_bpfel_x86.go 由于我们修改了 kprobe.c 中的函数名，所以此处也对应的发生了改变： type bpfProgramSpecs struct { KprobeOpenat2 *ebpf.ProgramSpec `ebpf:\"kprobe_openat2\"` } 我们需要将 main.go 一并更改（第44行）： kp, err := link.Kprobe(fn, objs.KprobeOpenat2) 然后更改fn为我们要 attach 的函数 do_sys_openat2（第26行）： fn := \"do_sys_openat2\" 最后，生成二进制文件并运行： $ go build \u0026\u0026 sudo ./YOUR_NAME 2022/03/23 17:01:03 Waiting for events.. 2022/03/23 17:01:04 do_sys_openat2 calle","date":"2022-03-15","objectID":"/cilium_ebpf/:0:3","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"参考文献 https://zhuanlan.zhihu.com/p/466893888 https://blog.csdn.net/qq_31362439/article/details/122727406 https://www.jianshu.com/p/a866147021da https://blog.csdn.net/jasonactions/article/details/116125922 https://szp2016.github.io/uncategorized/ebpf%E5%85%A5%E9%97%A8/ ","date":"2022-03-15","objectID":"/cilium_ebpf/:0:4","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["eBPF","Linux Kernel","Golang"],"content":"More about me 欢迎关注 「barryX的技术笔记」 微信公众号 ","date":"2022-03-15","objectID":"/cilium_ebpf/:0:5","tags":null,"title":"Cilium eBPF 搭建与使用","uri":"/cilium_ebpf/"},{"categories":["杂"],"content":"这篇文章是把博客从阿里云迁到腾讯云上之后的第一篇博客。 之前是在阿里云上使用WordPress搭建的，但是感觉比较臃肿，而且之前也就写过几篇博客，干脆就重新搭建一个。因为我现在一般都用Markdown格式写东西，所以就打算找一个利用Markdown生成静态网站的工具。 我目前有两台电脑，一台Windows笔记本、一台MacMini。 搭建了以下环境： Typora（编辑Markdown文档） 坚果云（作为Typora的工作目录，每次保存可以同步，也便于我在两台电脑之间切换） Gitee图床 (存放静态图片） PicGo （配置Typora，将图片自动上传到Gitee图床） 服务器端： Hugo （生成静态页面） Docker （容器化） Nginx （作为静态页面的web服务器） 并且我在Gitee上单独开了一个仓库，存放Hugo生成的站点，并且开通了Gitee Pages。 我的想法是这样的： 使用Typora编写内容。 将编写好的内容，放到Hugo中，并生成静态页面。（因为Nginx的网页目录就是public，所以此时已经可以通过域名访问到） 将站点通过git push到Gitee中，并在Gitee Pages中部署。 以上在环境方面的准备，接下来是内容方面的准备。 目前研一在读，研究方向大体为Linux Kernel、eBPF、内核网络、Golang这些，所以博客的内容主要以学习这些的笔记为主。 初学者难免会犯一些错误，如果有问题的话，欢迎大家向我指出！感谢！ 可以发邮件：i@barryx.cn 或者在Gitee中提交issue：https://gitee.com/barryx/barryx_blog/ ","date":"2022-03-15","objectID":"/hello_world/:0:0","tags":null,"title":"Hello World!","uri":"/hello_world/"}]